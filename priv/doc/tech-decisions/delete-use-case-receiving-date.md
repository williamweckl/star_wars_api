# Planet delete use case receiving deleted_at as input parameter

After many years developing Ruby applications with an Object Oriented mindset, when I was learning Elixir I had to change a little how I was writing code to a more functional mindset.

One of my main motivations to move from Ruby to Elixir was because of the side effects of the states generated by the Object Oriented approach. Developing using the functional paradigm makes the things more self contained, without side effects of things having a state that can be changed anywhere.

What I didn't realised at the time is that some common functions like functions to get the current date was also producing these side effects.

A function that uses something like the current date will always produce different outputs and it is also harder to test.

After learning a lot from great Elixir developers that I worked with at Xerpa company, I understood that side effects most of the time are not something that you can avoid. The database itself is something that holds state and most of the applications used at least one database.

Functions that persist data or retrieve data from the database can never be pure, this means that calling the same function again with the same arguments will produce different outputs.

What I try to do is to keep my functions as pure as possible, keeping what produces this side effects at more external layers of the application.

## The delete planet use case and the deleted_at field

What the delete planet use case does is to fill the deleted_at field and the ideia is to fill it with the current timestamp of the system.

To keep things purer, I decided to receive the `deleted_at` information as an argument instead of setting it directly to the current timestamp at the interactor. This decision made the code easir to test since I can test exacly the result I am expecting to happen.

Of course the interactor function is not pure because it depends on the database, but this is something I cannot avoid at this function. Basically the decision was to avoid side effects of what can be avoided.

With this decision made, the `deleted_at` parameter is being setted by the controller instead of the use case.

You can see the different implementations here:

  * [Delete Planet Interactor](https://github.com/williamweckl/star_wars_api/blob/main/lib/star_wars/interactors/planet/delete.ex#L31)
  * [Planet controller delete function](https://github.com/williamweckl/star_wars_api/blob/main/lib/star_wars_api/controllers/v1/planet_controller.ex#L31)

And the test implementations here:

  * [Testing deleted_at attribute at Interactor](https://github.com/williamweckl/star_wars_api/blob/main/test/star_wars/interactors/planet/delete_test.exs#L28)
  * [Testing deleted_at attribute at Controller](https://github.com/williamweckl/star_wars_api/blob/main/test/star_wars_api/controllers/v1/planet_controller_test.exs#L191)

Can you see that was much easier to test the interactor compared to the controller?

If the decision was to set the `deleted_at` to the current system timestamp at the interactor I would probably have to write the same weird and more complex test in both files.

Having functions easier to test most of the time means that you have a code that is also easier to be maintained. Some people defend that the test is also a client of the code/system you are writing.

## Different teams, different opinions

Of course there is no silver bullet, I've seen teams thinking and implementing things different and is ok too.

Some people could defend that setting the deleted_at as the current timestamp is a persistence rule or even it could be a business rule and this kind of rule should not be implemented at the controller.

I don't think they are wrong. I tend to think that these discussions always need to happen within teams, that this is healthy. After all it is very difficult to say what is right or wrong in software development, I believe more in a consensus of the team that is working on the system in question.
